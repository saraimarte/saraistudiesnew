---
layout: '@layouts/Blog.astro'
title: Programming in C
pubDate: 2025-02-07T00:00:00Z 
updatedDate: 2025-02-07T00:00:00Z
draft: true
author: Sarai Marte
slug: programming-in-c
---

 
import ImageMd from '@components/ImageMd.astro';
import Section from '@components/Section.astro';
import Code from '@components/Code.astro';
import RuleBox from '@components/Rule.astro';

import img1 from '@images/211/1.png';
import img2 from '@images/211/2.png';

<Section t= "Hello World Example + Compiling and Running Code Basics">

In every C program, we need a function called **main** that will return an integer. Think of it as boiler plate code- you will almost always need to write it like such. 

The integer returned will either be 0 or 1 and will represent weather the program ran successfully (0) or not(1).  

<Code lang = "c" fileName = "hello.c" code = {
    
`int main(){
    return 0;
}`}/>

Let's say you want to print **Hello World**. 

In C, the command to print is **printf**. 

<Code lang = "c" fileName = "hello.c" code = {
    
`int main(){
    printf("Hello World");
    return 0;
}`}/>

Now, this by itself won't work because **printf** is a function that comes with stdio.h. 

stdio.h is just a file that contains a collection of input/output functions.

One of the functions is **printf**. 

In order to use **printf**, you need to *include* stdio.h in your program at the top- as a header. 

That's why we call these header files.  

<Code lang = "c" fileName = "hello.c" code = {
    
`#include <stdio.h>
int main(){
    printf("Hello World");
    return 0;
}`}/>

Now, we're ready to run this! 

But first, like Java, we have to compile the code. 

First, open the terminal in VSCode using CTRL + J. 

## Compiling 

Compiling is just converting human-readable code into machine code (binary, 0's and 1's) that can be read (executed) by a machine. 

In C, the compiler we use is **gcc**. 

Remember, you are supposed to be connected to one of the ilabs while coding in this class. 

All the ilabs are set up the exact same way and have everything you need- including gcc. 

To compile we write **gcc** and then the name of the file we want to compile which in this case is **hello.c**. 

<Code lang = "c" fileName = "terminal" code = {`gcc hello.c`}/>

If you simply run this, and **ls** you will see a new file called **a.out**.  

That is the default name of the output file if you don't give it one. 

What the compiler did was compile the **hello.c** code and create what we call an **executable file** that is just the code but in 0's and 1's. 

Now, you may try to fact check me and open up the file using, **vim a.out** and you'll see the following, 

<ImageMd img = {img1} alt = ""/>

Then, you may be like "This isn't 0's and 1s!".

It is! It's just that if you open it in a text editor, it tries to display it as characters (ASCII or Unicode), resulting in gibberish like ^?ELF^B^A^A....

Now, let's say I don't want my output file to be called **a.out**. I want to give it it's own name. 

All I have to do is use something called a flag. A flag is just extra specifications you want to add to a command. 

We will use the **-o** flag which allows us to specify the name of the **o**output file. Instead of a.out i'm just going to call it **outputFile**. 

<Code lang = "c" fileName = "terminal" code = {`gcc hello.c -o outputFile`}/>

*You can do outputFile.out too. 

Now, if you run **ls**, you will see outputFile as the executable.

<ImageMd img = {img2} alt = ""/>

Another reason to name your output file is that if you compile without specifying a name, the compiler will default to a.out, overwriting it each time you compile.

## Running 

Now, run the file like so, 

<Code lang = "c" fileName = "terminal" code = {`./outputFile`}/>

</Section>

<Section t = "Compiling Code">

The most basic way to compile a file is by using gcc and then the file name.

<Code lang = "c" fileName = "terminal" code = {`gcc file.c`}/>

We also learned that there are things  called **flags**. They are just extra specifications we can add to commands. 

We already learned how to use one of them, that is the **-o** flag. 

<Code lang = "c" fileName = "terminal" code = {`gcc file.c -o outputFileName`}/>

We used it to give the **o**utput file a name but there are even more other flags!
 
Let's say we have a file called **hello.c** and w

**1. -Wall:** Enables all warnings.
<Code lang = "c" fileName = "terminal" code = {`gcc helloWorld.c -o -Wall`}/>

**2. -Wall -Werror:** Treats warnings as errors. 
<Code lang = "c" fileName = "terminal" code = {`gcc helloWorld.c -o -Wall`}/>

**3. -fsanitize=address:** Detects memory issues (AddressSanitizer)
<Code lang = "c" fileName = "terminal" code = {`gcc helloWorld.c -o -Wall`}/>


**4. -Wall -Werror: -fsanitize=address:** Combines output, warnings, errors and memory checks.  
<Code lang = "c" fileName = "terminal" code = {`gcc helloWorld.c -o -Wall`}/>

</Section>

<Section t = "Memory">


In Java, memory would see what is not being used up and remove it to save space in C you have to free up memory manually. 
</Section>

<Section t = "Data Types">

# Data Types 

**int:** integer (2, -3, 0)    
**char:** character ('a')   
**float:** decimal that takes up 32 bits of memory (3.141593)    
**double:** decimal that takes up 64 bits of memory (3.141592653500)   

**int signed:** can store both positive and negative numbers (int is signed by default so you don't have to specify it.) (2, -3, 0)   
**int unsigned:** can only store positive values and zero. (0, 1, 2, 3, 4...)  Have a larger range.  
**short:** Short Integers (consume 16 bits of memory)    
**long:** Long Integers (consume 32 bits of memory)    
**long long:**  Even longer Integers (consume 64 bits of memory)  

# Check Size of Data Type 

We can check how much memory a data type takes up using the built in **sizeof()** function. 

<Code lang = "c" fileName = "hello.c" code = {
`#include <stdio.h> //include this file that contains the printf function so you can use it

int main(){
    int num; //initialize a variable called num that will hold an integer; c will now allocate the needed amount of memory for that integer
 
    printf("%lu", sizeof(num)); //print the size of the integer 

    return 0; //return an integer since this main function is set to return an int 
}`}/>

Notice when printing the size of the integer, we format it using the **lu** format specifier. 

This stands for long unsigned long. Again by long we mean integer so it's an unsigned long integer. We use unsigned because how much memory a data takes up is never negative so no need for singed integers. Also, it's a long because sometimes data types will take a lot of memory.  



</Section>

<Section t = "Input and Output Functions">

# Importing i/o functions 

There already exists functions you can use to input or output data. 

To use these functions we simply have to import the file they are wrriten in.
 
In this case, the file is **stdio.h**. 

The **std** stands for standard and the **io** stands for input/output. 

We call these files header functions hence the **.h** extension in stdio.**h**  

We import the file and any file (as long as it's one that comes with C) using `#include <fileName>`

<Code lang = "c" fileName = "fileName.c" code = {`#include <stdio.h>`}/>

This file includes functions like **printf** and **scanf**. 

The f stands for 'formatted' because for whatever we print or scan- we have to specify the format we want to print or read it in. 
 
# Printing Using Formatting 
For example, let's say I want to print an integer. If we try,

<Code lang = "c" fileName = "fileName.c" code = {`printf(2); //"print this thing"`}/>

That will give us an error saying you're missing format arguments—and you are!

In C, whenever we print something, we must specify the format. Since we're printing an integer in this case, we need to use the integer format specifier: %d.

%d: The "d" stands for "decimal integer," referring to decimal numbers which we’ve used since kindergarten, which represents numbers using digits 0-9, as opposed to binary. 

<Code lang = "c" fileName = "fileName.c" code = {`printf("%d", 2);//"print this integer"`}/>

<RuleBox>
Here, are the format specifiers for other data types.  

%d: Integer    
%f: Float     
%c: Character  
%s: String 
%lu: Long Unsigned Integer 
</RuleBox>

Let's say you want to print out a sentence that contains variables,

<Code lang = "c" fileName = "fileName.c" code = {
    
`#include <stdio.h> //include to use printf()

int main(){
    int age; 
    int favNumber; 

    age = 21;
    favNumber = 13;

    printf("I'm %d years old and my favorite number is %d\\n", age, favNumber);

    return 0;
}`}/>

Notice how the variables in the sentence are replaced with their format specifiers and then you list the variables in the order you want them to appear, so age then favNumber. 

# Scanning Using Formatting 

<Code lang = "c" fileName = "fileName.c" code = {`scanf("%d", &num)`}></Code>
</Section>

<Section t = "Conditional Statements, Iteration, Break and Continue">

</Section>

<Section t = "Functions">

</Section>

<Section t = "Type Casting">

One cool thing we can do in C is convert a variable from one data type to another. This is called type casting, and it can be done in two ways:

Implicitly – When C automatically converts a value to a different type.  
Explicitly – When we manually tell C to convert a value using type casting syntax.  

# Implicit Type Casting

In implicit type casting, C automatically converts one data type to another when needed. For example, a double can be converted to an int (like 10.5 to 10) without any extra effort:

<Code lang = "c" fileName = "fileName.c" code = {
`double a = 10.5; //set double to 10.5

int b = a; //create an integer and set it to a - C will automatically strip away the anything after the decimal so that a becomes an integer. 

printf("%f %d\\n", a,b); //10.500000 10`}></Code>

Here, C automatically converts **a** from an int to a double because **b** is declared as a double. No extra syntax is needed—C just does it for us!

# Explicit Type Casting

Explicit type casting is when we manually tell C to change a variable’s type using (type) before the value.

<Code lang = "c" fileName = "fileName.c" code = {
`double a = 10.5; //set double to 10.5

int b = (int)a; //explicity say "hey, I want a to be an integer" and set that to an int called b

printf("%f %d\\n", a,b); //10.500000 10`}></Code>

Here, we force C to remove the decimal part of **a** by using (int)a. This means **b** stores only the whole number 10, with everything after the decimal point removed.

In both cases, casting implicitly or explicity does not matter. Both ways do the same thing except doing it explicity is more readable. 

# Why Use Explicit Casting?

Now, you may ask, other than readability, why would you use explicit casting if implicit does the same thing?

## EX1| Dividing Integers a/b
Let's look at this example, 

<Code lang = "c" fileName = "fileName.c" code = {
`//you have 2 integers, 5 and 3 
int a = 5, b = 3;

//you divide a by b and set it to a variable of data type of double 
double result = a/b; //note that the division happens FIRST then it's assigned as a double.

printf("Result: %f\\n", result); //Result: 1.000000
`}></Code>

Note that the division a/b happens first.

Also note that **a** and **b** are both integers so integer/integer will give you the same datatype- an integer. 

In this case it will be 5/3 = 1. 

*Then,* what a/b gave is assigned to a variable called **result** that is a double so it will take the 1 and make it a 1.000000. 

Following the same logic as above, the only way we can get a double as an answer is if we did double/double. 

We have to explicity say, "hey, BEFORE you divide a/b, turn them into doubles so that the answer may be a double."

<Code lang = "c" fileName = "fileName.c" code = {`double result = (double)a/(double)b; //this is saying "hey, turn a and b into doubles before dividing a/b. That way, the result will be a double instead of an integer. Then store it as a double called result.`}></Code>

Now, that works fine but a nice thing about C is that it only needs *one* of them to be a double and it will convert the other one to a double aswell. 

<Code lang = "c" fileName = "fileName.c" code = {`double result = (double)a/b; //this is saying "hey, turn a into a double before dividing a/b. That way, C will implicitly convert b to a double as well and the result will be a double instead of an integer.`}></Code>

So, we don't need double/double to get a double we can also do double/integer and C will convert that integer into a double.

Hence, the only way that a/b would give a double is if a and b were initialized as doubles in the first place or if at least one of them was or is made a double. 

And this is only possible using explicit casting!

# Casting with Signed and Unsigned Casting

Casting with singed and unsigned numbers may result in unexpected outputs. For example, 

<Code lang = "c" fileName = "fileName.c" code = {
`int signed num = -3; //singed number (singed because it literally has a sign- a negative sign)

int unsigned unsignedNum = (unsigned int)num; //change the datatype of number to unsigned datatype (aka removes the sign- at least that's what you expect it to do) 

printf("Result: %d, %u\n", num, unsignedNum); //Result: -3, 4294967293`}></Code>

Interesting how we took a signed number -3, changed it's data type to unsigned which you would think would remove the sign and give you 3 but instead it gave you 4294967293. Why?

</Section> 
 
<Section t = "Debugger">

</Section>

<Section t = "Arrays">

arr is a pointer to the first element of the array
</Section>
 
<Section t = "Struct">
</Section>

<Section t = "Pointers">
dereferencing 
how does it know when to stop when reading array of chars for a string? it stops when it reaches the null character. 
</Section>