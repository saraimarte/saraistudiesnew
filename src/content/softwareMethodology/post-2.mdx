---
layout: '@layouts/Blog.astro'
title: Lecture 2 | Inheritance & Polymorphism in Java
pubDate: 2025-09-04T00:00:00Z 
updatedDate: 2025-09-04T00:00:00Z 
draft: false
author: Sarai Marte
slug: lecture-2-inheritance-in-java
---

import Code from '@components/Code.astro';
import Solution from '@components/Solution.astro'
import CS from '@components/CSnippet.astro';
import RuleBox from '@components/Rule.astro';

# Inheriting Attributes 

Let's begin with the Point class from last lecture. 

**What attributes would a point have?**

It's x and y values. 

Let's create the Point class with x and y as it's attributes.

<Code lang = "java" fileName = "File.java" code = {
`class Point {
     int x;
	   int y;
}`}/>

What if we wanted to create a new object called ColoredPoint?

**What attributes would a colored point have?**

Well, it would also have x and y values and a color!

Let's create the Colored Point class with it's attributes.

<Code lang = "java" fileName = "File.java" code = {
`class ColoredPoint {
     int x;
	   int y;
	   String color;
}`}/>

Note that both the Point and the Colored Point have common attributes like x and y.

And isn't a colored point just a point... but with a color?

So what if we could save some time by having the ColoredPoint class inherit the x and y attributes that every Point has from the Point class?

In ColoredPoint I can just extend the attributes (the genes/traits) of the Point class to the ColoredPoint class.

**1.** Let's take the Colored Point class and extend the Point class 

<Code lang = "java" fileName = "File.java" code = {
`class ColoredPoint extends Point {
	
}`}/>

At this point the ColoredPoint class has inherited all the attributes of the Point class. 

That means it has inherited the x and y attributes.

Meaning if I create and initialize a new ColoredPoint object like so: <CS code = {`ColoredPoint coloredPoint = new ColoredPoint();`}/> directly followed by <CS code = {`System.out.println(coloredPoint.x);`}/>- I get 0. 

I won't get a compiling error even though there is no x or y attribute defined in the ColoredPoint class.

Why?

**i.** Recall that when you fail to add your own constructor to a class, the compiler will do it for you and add the default constructor.

So, if you thought that it would give a compiling error because of the fact we called a constructor () that we didn't write- that is not the case. 

**ii.** The ColoredPoint class does not have an x or y attribute. You don't see <CS code = {`int x; int y;`}/> in the class. In fact, there is nothing that we wrote inside the class and yet <CS code = {`coloredPoint.color`}/> works because the ColoredPoint class inherited the x and y traits/attributes from the Point class. 

Think of a child inheriting traits from their parent.

The child class (ColoredPoint) is what we call the subclass and the parent class (Point) is what we call the superclass.

<RuleBox>
**Def.** A **subclass** is a class that extends (inherits from) another class which we call the **superclass.**
</RuleBox>

**2.** Now, let's add what's unique to the ColoredPoint class and that is the color!

<Code lang = "java" fileName = "File.java" code = {
`class ColoredPoint extends Point {
		
}`}/>

**Q:** What happens if I do <CS code = {`ColoredPoint coloredPoint = new ColoredPoint();`}/> directly followed by <CS code = {`System.out.println(coloredPoint.color);`}/>?

**A:** I get null because the color is a String and the default value for the String is null. Why are we getting default values? Because we didn't write a constructor for the ColoredPoint class to accept the color from the user so the color is stuck being the default value that <CS code = {`new`}/> assigned upon creation of the object.

**3.** Let's add a constructor that accepts the color from the user

<Code lang = "java" fileName = "File.java" code = {
`class ColoredPoint extends Point {
		String color;

		ColoredPoint(String color) {
			this.color = color; /*this object's color = the user's input color*/
		}
}`}/>

**Q:** What do I get if I do <CS code = {`ColoredPoint coloredPoint = new ColoredPoint("Blue");`}/> directly followed by <CS code = {`System.out.println(coloredPoint.color);`}/>?

**A:** I get Blue. 

# Inheriting Methods 

In the same way we inherit attributes we can also inherit methods.

Let's say we have a the Point class with a method called display() that prints out the point in the form (x,y).

<Code lang = "java" fileName = "File.java" code = {
`class Point {
     int x;
	   int y;

	  String display() {
		return "Point: (" + x + "," + y + ")";
		/*This returns out the point in the form Point: (x,y)*/
	}

}`}/>

Now, let's create a ColoredPoint class that extends the Point class. 

<Code lang = "java" fileName = "File.java" code = {
`class ColoredPoint extends Point {
		
}`}/>

Note that there is nothing that we wrote inside the ColoredPoint class and yet it has inherited all the attributes and methods from the Point class.

Meaning if I create and initialize a new ColoredPoint object like so: <CS code = {`ColoredPoint coloredPoint = new ColoredPoint();`}/> directly followed by <CS code = {`coloredPoint.display();`}/>- I will get Point: (0,0) printed in the terminal. 

**Q:** Why are x and y 0? 

**A:** Because we didn't write a constructor for the ColoredPoint class to accept the x and y values from the user so they are stuck being the default values that <CS code = {`new`}/> assigned upon creation of the object.

## Overriding Inherited Methods

Let the Point class look like this:

<Code lang = "java" fileName = "File.java" code = {
`class Point {
     int x;
	   int y;

	 Point(int x, int y){
		this.x = x;
		this.y = y;
	 }
	
	String display() {
		return "Point: (" + x + "," + y + ")";
		/*This returns out the point in the form Point: (x,y)*/
	}
	
}`}/>

and our subclass ColoredPoint look like this:

<Code lang = "java" fileName = "File.java" code = {
`class ColoredPoint extends Point {
		String color;
}`}/>

What if I wanted the ColoredPoint class to have a different display() method that prints out the point in the form Point: (x,y) Color: color?

How can we make it so without changing anything in the superclass?

We can override the inherited method by writing a new display() method in the ColoredPoint class.

For example, 

<Code lang = "java" fileName = "File.java" code = {
`class ColoredPoint extends Point {
		String color;

		String display() {
			return "Point: (" + x + "," + y + ")" + " Color: " + color;
		}
}`}/>

If you run the code above like so:

<Code lang = "java" fileName = "File.java" code = {
`ColoredPoint coloredPoint = new ColoredPoint();

coloredPoint.display();`}/>

you get Point: (0,0) Color: null.

**Q:** Why are x and y 0 and color null?   
**A:** Again, because we didn't write a constructor for the ColoredPoint class to accept the x, y, and color values from the user so they are stuck being the default values that <CS code = {`new`}/> assigned upon creation of the object.

Now, note that the ColoredPoint *did* inherit the display() method from the Point class but since we overrode it by writing a method with the same name- the compiler will ignore the inherited display() method and use the one we wrote in the ColoredPoint class.

## Reusing Inherited Method Code in Overriding Method 

Now, looking at the previous ColoredPoint class below:

<Code lang = "java" fileName = "File.java" code = {
`String display() {
		return "Point: (" + x + "," + y + ")" + " Color: " + color;
}`}/>

note that <CS code = {`"Point: (" + x + "," + y + ")"`}/> actually comes from the Point class's display() method so instead of us re-writing it, it is best practice to reuse the inherited code .

How? By replacing it with a call to the superclass' display() method that returns the same thing like so:

<Code lang = "java" fileName = "File.java" code = {
`String display() {
		return super.display() + " Color: " + color;
}`}/>

# More on Subclasses 

<RuleBox>
**Rule:** The first statement in a subclass constructor has to call the superclass' constructor using the <CS code = {`super()`}/> keyword.
</RuleBox>

Why does this rule exist?

**The Problem:** Without this rule, a subclass constructor would only be responsible for initializing its own attributes, like color in the ColoredPoint. 

The inherited attributes from the superclass, such as x and y from Point, would be left uninitialized or would have default values (like zero).

**The Solution:** <CS code = {`super()`}/> guarantees that the inherited part of the object has been initialized before any new subclass-specific attributes are initialized. By calling <CS code = {`super()`}/>, the ColoredPoint class trusts the Point class to do its job, without needing to know the details of how x and y are initialized.

For example, let the Point class look like this:

<Code lang = "java" fileName = "File.java" code = {
`class Point {
     int x;
	   int y;

	 Point(int x, int y){
		this.x = x;
		this.y = y;
	 }
}`}/>

and let the ColoredPoint class look like this:

<Code lang = "java" fileName = "File.java" code = {
`class ColoredPoint extends Point {
		String color;

		ColoredPoint(int x, int y, String color) {
			this.color = color; 
		}
}`}/>

**Q:** Would the code above compile?

**A:** No. It would give you this error: Implicit super constructor Point() is undefined. Must explicitly invoke another constructor. 

What's the fix? Call the superclass constructor using <CS code = {`super(x,y);`}/> as the first statement in the ColoredPoint constructor.

<Code lang = "java" fileName = "File.java" code = {
`ColoredPoint(int x, int y, String color) {
		super(x,y); /* Call the superclass constructor to initialize x and y */
		this.color = color; 
}`}/>

As a programmer, you know that ColoredPoint is a Point so x and y which are fields of a Point should also be passed in when creating a ColoredPoint object.

Now, you can re-write the constructor that takes in x and y in the subclass but note that x and y also are fields of the Superclass Point and what if the Point constructor has different or more complex logic to initialize x and y and you don't know about it because you can't see the superclass. This causes a problem because it violates the principle of encapsulation and risks bypassing the parent's established, tested initialization code, which is why Java makes it a rule that you must call the super constructor.


The Point class is responsible for initializing the X and Y coordinates correctly. By calling super(x, y), you are delegating that responsibility to the code that was tested and proven to work in the superclass (Point).

The subclass (ColoredPoint) should only focus on initializing its own unique part, the color.

## Polymorphism

<RuleBox>
**Def.** **Polymorphism** is the ability of an object to take on many forms. It allows a variable of a superclass type (like Point) to hold the reference to an object of a subclass type (like ColoredPoint)
</RuleBox>

Polymorphism allows you to do the following: 

<CS code = {`Point p2 = new ColoredPoint(1,2, "blue");`}/> 

Notice, how we're creating a new ColoredPoint object and yet we are making it of type Point?

Shouldn't it be of type ColoredPoint? 

Yes, it can be but this is still correct. 

An easy way to understand is by recalling that every ColoredPoint is a Point so a ColoredPoint as an object can be of type Point.

However, the other way around doesn't work. 

Not every Point is a ColoredPoint so we can't have a Point Object created with type coloredPoint like so:

<CS code = {`ColoredPoint p2 = new Point(1,2, "blue");`}/> 

# Static and Dynamic Types 

Up until now, we have been used to using types like int, double, String, etc.

Because Java has objects, we have something called dynamic types.

Note that in C, there are no objects and hence there is no such thing as dynamic types in C. 

At this point, Sesh only wants you to develop the following skill: Be able to answer what is the type in compile time (static) vs runtime (dynamic.)

<RuleBox>
**Def.** A **static type** is the type that a variable is declared to be at compile time. It's a property of a class just like <CS code = {`random`}/> is a static method of the <CS code = {`Math`}/> library. Simply, it's the class that you see at the start of a variable declaration.  
</RuleBox>

<RuleBox>
**Def.** A **dynamic type** is the actual type of the object that a variable references at runtime. Simply it's the class that an object is initialized with (the class after the <CS code = {`new`}/> keyword.)
</RuleBox>

**E.g.** In <CS code = {`Object o = new String("hello");`}/> 

Static Type: Object  
Dynamic Type: String   

**E.g.** In <CS code = {`Point p2 = new ColoredPoint(1,2, "blue");`}/> 

Static Type: Point   
Dynamic Type: ColoredPoint    

**E.g.** In <CS code = {`Point p1 = new Point(1,2);`}/> 

Static Type: Point   
Dynamic Type: Point    

**E.g.** In <CS code = {`Object o2 = p2;`}/> 

Static Type: Object   
Dynamic Type: ColoredPoint    
Explanation: Recall from the 2nd example we just did, p2 is a variable with a static type Point that references the object whose dynamic type is ColoredPoint. 
The point is that the dynamic type of an object remains the same no matter what variable references it whether it's o2 or p2. 

## Dynamic Binding 

<RuleBox>
**Def.** **Dynamic Binding** is the process that allows the Java to determine which overridden method to execute at runtime (instead of compile time.)


To Java it's a process. To us it's a simple rule.  

If you 

It only comes into play when there is overriding of methods.

</RuleBox>

**E.g.** If a subclass Object has a more specialized, overridden version of a method that is in the superclass, dynamic binding ensures that this more specific (overwritten) version is the one that gets called instead of the method in the superclass. 
