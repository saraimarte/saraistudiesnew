---
layout: '@layouts/Blog.astro'
title: Problem Set 1 Recitation
pubDate: 2025-09-04T00:00:00Z 
updatedDate: 2025-09-04T00:00:00Z 
draft: true
author: Sarai Marte
slug: problem-set-1-recitation
---

import Code from '@components/Code.astro';
import Solution from '@components/Solution.astro'

**1.** Consider the following class definition:

<Code lang = "java" fileName = "File.java" code = {
      ` public class A {
          public A () {}
          public A (int a, int b) {}
       }

       public class B extends A {
            public B (int r) {}
            public B (int r, int w) { 
               super (r, w);
            }
       }`}/>

Which of the following are legitimate calls to construct instances of the B class? For those that are not, explain why.

a. B c = new B();  
b. A s = new B(1);  
c. B c = new B(1, 9);  
d. A t = new B(1, 9, 4);  
e. B t = (new B(1)).new B(1);  
f. B b = new A(1, 2);

<Solution>
B and C are valid calls.
</Solution>

**2.** Will the following code compile? If not, where exactly will it fail to compile? 

<Code lang = "java" fileName = "File.java" code = {

`public class A {
    public int x;
    public A(int x) {
      this.x = x;
    } 
  }

  public class B extends A {
    public int y;
    public B(int y) {
      this.y = y;
    }}`}/>

**e.** 

<Code lang = "java" fileName = "File.java" code = {

`public class G {
     public int g;
  }

  public class H extends G {
     public int h;
     public boolean equals(Object o) {
        if (o == null || !(o instanceof H)) { 
           return false; 
        }
        return g == ((H)o).g;
     }
  }`}/>

  <Solution>
20
</Solution>

<Code lang = "java" fileName = "File.java" code = {

`public class B {
    public int x;
    public String toString() {
       return x + "";
    }
  }

  public class E extends B {
    public int y=3;
    public String toString() {
       return (x + y) + "";
    }
  }`}/>


**f.** 

<Code lang = "java" fileName = "File.java" code = {

`public class B {
    public int x;
    public String toString() {
       return x + "";
    }
  }

  public class E extends B {
    public int y=3;
    public String toString() {
       return (x + y) + "";
    }
  }`}/> 

What is the output of the following code segment, which is in a different class than B or E: 

<Solution>
Fail to compile because static type checker sees type B but class B doesn't have y as an attribute/instance variable/field
</Solution>

**3.** What is the output of this code? Why? 

<Code lang = "java" fileName = "File.java" code = {

`class GrandParent { }
   class Parent extends GrandParent{ }
   class Child extends Parent { }

   class Foo {
      public void bar(GrandParent p) {
         System.out.println("called with type GrandParent");
      }
      public void bar(Parent p) {
         System.out.println("called with type Parent");
      }
   }

   public class Test {
      public static void main(String[] args) {
         new Foo().bar(new Child());
      }
   }`}/>

<Solution>

</Solution>

