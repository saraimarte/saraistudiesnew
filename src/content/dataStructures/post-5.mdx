---
layout: '@layouts/Blog.astro'
title: Stacks & Queues
pubDate: 2024-09-16T00:00:00Z 
updatedDate: 2024-09-16T00:00:00Z 
draft: false
author: Sarai Marte
slug: linked-lists
---

import ImageMd from "@components/ImageMd.astro";
import CI from '@components/CI.astro';

import img1 from '@images/112/8.svg';
import img2 from '@images/112/9.svg';

import Code from '@components/Code.astro';

# Stacks 

Stacks is another data structure- think about a stack of books.

You can stack one book on top of another but when you want to remove one you have to start from the top. 

In other words, it's last in last out (LIFO) data structure.

There are only two methods we need to do for the stack data structure- push and pop aka add and delete. 

Actually, we already built a stack. A linked list is a stack.

It's a data structure where when we add a node, we add it to the top and when we want to delete a node we have to delete the first/top one. 

Really, you can simply replace the addFirst() and delteFirst() method names from <a href = "https://saraistudies.netlify.app/datastructures/linked-lists/">our linked list code</a> with push() and pop() because they're the exact same thing.

It would look like so,

<Code lang = "java" fileName = "StackOfStrings.java" code = 
{`public class StackOfStrings {

    // Static inner class for Node
    private static class Node {
        private String item; // Stores the value of the node
        private Node next; // Points to the next node in the list
    }

    // Static inner class for LinkedList
    public static class LinkedList {

        private Node first = null; // The first node in the list

        // Adds a new node to the beginning of the list
        public void push(String item) {
            Node temp = new Node(); // Create a new node
            temp.item = item; // Set the value
            temp.next = first; // Point new node to the current first node
            first = temp; // Update first to point to the new node
        }

        // Deletes the first node and returns its value
        public String pop() {
            if (first == null) {
                return null; // Handle empty list case
            }
            String item = first.item; // Get the value of the first node
            first = first.next; // Update first to point to the next node
            return item; // Return the value of the deleted node
        }
    }
}`}>
</Code>

Now, create a stack, push (add) the items "Spongebob", "Patrick", "Squidward" and "Sarai" to the stack.

<CI img = {img1} alt = "" lang = "java" fileName = "StackOfStrings.java" code = 
{`public static void main(String[] args){

        // Create an instance of the LinkedList
        LinkedList myList = new LinkedList();

        myList.push("Spongebob");
        myList.push("Patrick");
        myList.push("Squidward"); 
        myList.push("Sarai");
    }
`}></CI>

Now, pop (remove) Spongebob from the stack.

Oh wait... you can't. You don't choose what to remove.

You can only choose what to add. 

Since stacks are last in first out (LIFO) then only the last thing that was pushed into the stack is the one thing that can be popped.

So, if you run this, 

<CI img = {img2} alt = "" lang = "java" fileName = "StackOfStrings.java" code = 
{`myList.pop();
    System.out.print(myList.pop());
}
`}></CI>

then what it popped from the stack is what was last added and that is "Sarai". Now, you no longer see "Sarai" anymore.

Now, we went over stacks from a linked list approach but we can also write them using arrays so let's see what that looks like. 

# ArrayStackOfStrings

A problem with this approach is that the array has a fixed size. So once it fills up then no more items can be pushed into the stack but let's see it anyway.

<Code lang = "java" fileName = "FixedCapacityStackOfStrings.java" code = 
{`public class FixedCapacityStackOfStrings {
 
    private String[] s;
    private int n=0;

    // notice that n points to the position
    // where the next element
    // will be added

    public FixedCapacityStackOfStrings(int capacity){
        s=new String[capacity];
    }

    public boolean isEmpty(){
        return n==0;
    }

    public void push(String item){
      s[n++]=item;
    }

    public String pop(){
        String item=s[--n];
        s[n]=null; // avoid memory leak
        return item;
    }

    public int size(){
        return n;
    }

    public void traverse(){
        for (int i=0;i<n;i++){
        System.out.println(s[i]);
    }}

}`}>
</Code>

# ResizingArrayStackOfStrings

Now, how can we have the array resize itself.

Well, first, we have to keep track of size.























